# Description:
#   Track tokens given to acknowledge contributions from others
#
# Dependencies:
#   None
#
# Configuration:
#   TOKEN_ALLOW_SELF
#   TOKENS_CAN_BE_TRANSFERRED
#   TOKEN_ALLOWANCE
#   ALLOWANCE_FREQUENCY
#   TIMEZONE
#
# Commands:
#   hubot give @user_name - Gives one token to `@user_name`.
#   hubot give a token to @user_name - Gives a token to `@user_name`.
#   hubot status @user_name - Returns the status of `@user_name`'s tokens.
#   hubot status of @user_name - Returns the status of `@user_name`'s tokens.
#   hubot show users - Returns a list of all the users that the bot knows about.
#   hubot who has tokens - Returns a list of all users who still have tokens to give out.
#   hubot who has tokens to give? - Returns a list of all users who still have tokens to give out. Try to help these users so that they thank you with a token!
#   hubot show users with tokens - Returns a list of all users who still have tokens to give out. Try to help these users so that they thank you with a token!
#   hubot leaderboard - Returns the top 10 users with the most tokens.
#   hubot show top n list - Returns the top n users with the most tokens, where n is a positive integer.
#
# Author:
#   Charlie Brummitt <brummitt@gmail.com> Github:cbrummitt

# Environment variables:
#   TOKEN_ALLOW_SELF = false
#   TOKENS_CAN_BE_TRANSFERRED = true
#   TOKEN_ALLOWANCE = 7
#   ALLOWANCE_FREQUENCY = '59 59 23 * * 0'  # every Sunday at 11:59:59 PM; see https://github.com/kelektiv/node-cron#cron-ranges
#   TIMEZONE = "America/New_York"
Util = require "util"  # for inspecting an object with `Util.inspect`
# Cron = require "cron"  # for running jobs
# CronJob = Cron.CronJob
CronJob = require('cron').CronJob


TOKEN_ALLOWANCE = process.env.TOKEN_ALLOWANCE or 7
ROOM_ANNOUNCE_ALLOWANCE = process.env.ROOM_TO_ANNOUNCE_ALLOWANCE or "general"
# default allowance frequency: every Sunday at 11:59:59 PM
# see https://github.com/kelektiv/node-cron#cron-ranges
# TODO: Create an English description of the frequency using
# https://stackoverflow.com/questions/321494/calculate-when-a-cron-job-will-be-executed-then-next-time
# perhaps
# https://bitbucket.org/nevity/cronner
# ALLOWANCE_FREQUENCY = process.env.ALLOWANCE_FREQUENCY or "59 59 23 * * 0"
# ALLOWANCE_FREQUENCY = '* * * * * *' # every second
# every 10 seconds: '*/10 * * * * *' # every 10 seconds
# Seconds: 0-59
# Minutes: 0-59
# Hours: 0-23
# Day of Month: 1-31
# Months: 0-11
# Day of Week: 0-6

class TokenNetwork
  constructor: (@robot) ->
    # a dictionary mapping a user ID to a list of user IDs that specifies
    # whose tokens have been given to whom:
    # {sender_id : [recipient_1, recipient_2, ...], ...}
    @tokens_given = {}

    # a dictionary mapping a user ID to a list of user IDs that specifies
    # who has received tokens from whom:
    # {recipient_id: [sender_1, sender_2, ...], ...}
    @tokens_received = {}

    # a dictionary of how many tokens each person has available to give;
    # it maps each user's id to a non-negative integer
    @token_wallet = {}

    for own key, user of robot.brain.data.users
      @initialize_user(user['id'])

    # If the brain was already on, then set the cache to the dictionary
    # `@robot.brain.data.tokens_given`.
    # The fat arrow `=>` binds the current value of `this` (i.e., `@`)
    # on the spot.
    @robot.brain.on 'loaded', =>
      if @robot.brain.data.tokens_given
        @tokens_given = @robot.brain.data.tokens_given
      if @robot.brain.data.tokens_received
        @tokens_received = @robot.brain.data.tokens_received
      if @robot.brain.data.token_wallet
        @token_wallet = @robot.brain.data.token_wallet

  recognize_user: (user_id) ->
    return (@tokens_given[user_id]? and
            @tokens_received[user_id]? and
            @token_wallet[user_id]?)

  initialize_user: (user_id) ->
    @tokens_given[user_id] = []
    @tokens_received[user_id] = []
    @token_wallet[user_id] = TOKEN_ALLOWANCE

  initialize_user_if_unrecognized: (user_id) ->
    if not @recognize_user(user_id)
      @initialize_user(user_id)

  reset_everyones_wallet: () ->
    for own key, user of @robot.brain.data.users
      @token_wallet[user['id']] = TOKEN_ALLOWANCE

  give_token: (sender, recipient, num_tokens_to_transfer) ->
    # Give a certain number of tokens from one user ID to another user ID.

    # Prepend `@` to the user names so that the users are notified by the
    # message generated by this method.
    sender_name = "@" + @robot.brain.userForId(sender).name
    recipient_name = "@" + @robot.brain.userForId(recipient).name

    if num_tokens_to_transfer == 0
      return "#{sender_name}: I can't let you send *zero* tokens :)"

    num_tokens_to_give = Math.min(num_tokens_to_transfer, @token_wallet[sender])
    if num_tokens_to_give <= 0
        return ("#{sender_name}: you do not have any more tokens available " + 
                "to give to others. You will have to wait until you receive " +
                "more tokens next week.")
        # TODO: is there a way to translate a cron time to an English
        # description and use that here? (instead of "next week")
    else
      # update @tokens_given
      @tokens_given[sender].push recipient for index in [1..num_tokens_to_give]
      @robot.brain.data.tokens_given = @tokens_given

      # update @tokens_received
      @tokens_received[recipient].push sender for index in [1..num_tokens_to_give]
      @robot.brain.data.tokens_received = @tokens_received

      # update @token_wallet
      @token_wallet[sender] = @token_wallet[sender] - num_tokens_to_give
      @robot.brain.data.token_wallet = @token_wallet

      # create a message to be sent in the channel where the command was made
      token_or_tokens = if num_tokens_to_give != 1 then "tokens" else "token"
      message = ("#{sender_name} gave #{num_tokens_to_give} " + 
                 "#{token_or_tokens} to #{recipient_name}. ")
      tokens_remaining = @token_wallet[sender]
      token_or_tokens = if num_tokens_to_give != 1 then "tokens" else "token"
      message += ("#{sender_name} now has #{tokens_remaining} " + 
                  "#{token_or_tokens} remaining to give to others. ")
      return message

  selfDeniedResponses: (name) ->
    @self_denied_responses = [
      "Sorry #{name}. Tokens cannot be given to oneself.",
      "I can't do that #{name}. Tokens cannot be given to oneself.",
      "Tokens can only be given to other people."
      "Nice try #{name}! Unfortunately I can't let you give a token to yourself."
    ]

  tally: (list_of_strings) -> 
    count = {}
    for x in list_of_strings
      if count[x]? then count[x] += 1 else count[x] = 1
    return count

  status: (id, self_bool) -> 
    # Return a string describing the status of a user.
    # The status is the number of tokens left in the user's wallet,
    # the number of tokens given and received (to whom and from whom).
    # Inputs: 
    #  1. id is the ID of the user for which we'll return the status; 
    #  2. self_bool is a boolean variable for whether the person writing this
    #     command is the same as the one for which we're returning the status
    # Example:
    # @name has 2 tokens remaining to give to others.
    # @name has given tokens to the following people: 
    #   @user_4 (1 token)
    #   @user_8 (2 tokens) 
    # @name has received 2 tokens from others: 
    #   @user_4 (1 token)
    #   @user_5 (1 token)

    name = if self_bool then "You" else "@" + @robot.brain.userForId(id).name

    # list of the people to whom `name` has given tokens
    tokens_given_by_this_person = if @tokens_given[id]? then @tokens_given[id] else []
    num_tokens_given = tokens_given_by_this_person.length
    # number of tokens this person has left to give others
    tokens_remaining = @token_wallet[id]

    # build up a string of results
    result = ""

    has_have = if self_bool then "have" else "has"
    token_or_tokens = if tokens_remaining != 1 then "tokens" else "token"
    result += ("#{name} #{has_have} #{tokens_remaining} #{token_or_tokens}" +
               " remaining to give to others. ")
    result += "\n"

    # number of tokens `name` has given to others (and to whom)
    if num_tokens_given > 0
      token_or_tokens = if num_tokens_given != 1 then "tokens" else "token"
      result += ("#{name} #{has_have} given #{num_tokens_given}" +
                 " #{token_or_tokens} to the following people: ")
      result += ("@" + @robot.brain.userForId(id_peer).name + " (" +
                 num_tokens.toString() + ")" for own id_peer, num_tokens of @tally(tokens_given_by_this_person)).join(", ")
    else
      result += "#{name} #{has_have} not given any tokens to other people. "
    result += "\n"


    # number of tokens `name` has received from others (and from whom)
    tokens_received_by_this_person = if @tokens_received[id]? then @tokens_received[id] else []
    num_tokens_received = tokens_received_by_this_person.length
    if num_tokens_received > 0
      token_or_tokens = if num_tokens_received != 1 then "tokens" else "token"
      result += ("#{name} #{has_have} received #{num_tokens_received} " + 
                 "#{token_or_tokens} from the following people: ")
      result += ("@" + @robot.brain.userForId(id_peer).name +
                 " (" + num_tokens.toString() + ")" for own id_peer, num_tokens of @tally(tokens_received_by_this_person)).join(", ")
    else
      do_or_does = if self_bool then "do" else "does"
      result += "#{name} #{do_or_does} not have any tokens from other people."
      if self_bool
        result += " Give feedback to others on their business ideas, so"
        result += " that they thank you by giving you a token!"
      else
        result += " If #{name} has given you useful feedback on your business"
        result += " idea, then make sure to thank them with a token by writing"
        result += " `/give #{name}`."

    #result += ("\n\n Debugging: \n tokens_given_by_this_person = " +
    #           "#{Util.inspect(tokens_given_by_this_person)} \n tokens_received_by_this_person = #{Util.inspect(tokens_received_by_this_person)}"
    return result

  leaderboard: (num_users) -> 
    user_num_tokens_received = (\
      [@robot.brain.userForId(user_id).name, received_list.length] \
      for own user_id, received_list of @tokens_received
    )

    if user_num_tokens_received.length == 0
      return "No one has received any tokens."

    # sort by the number of tokens received (in decreasing order)
    user_num_tokens_received.sort (a, b) ->
      if a[1] > b[1]
         return -1
      else if a[1] < b[1]
         return 1
      else
         return 0

    # # build up a string `str` 
    limit = Math.min(num_users, user_num_tokens_received.length) #5
    str = "These #{limit} users have currently been thanked the most:\n"
    for i in [0...limit]
      username = user_num_tokens_received[i][0]
      points = user_num_tokens_received[i][1]
      point_label = if points == 1 then "token" else "tokens"
      leader = ""
      newline = if i < limit - 1 then '\n' else ''
      str += "#{i+1}. @#{username} (#{points} " + point_label + ") " + leader + newline
    return str


# helper function that converts a string to a Boolean
# for using the Boolean environment variables TOKENS_CAN_BE_TRANSFERRED and TOKEN_ALLOW_SELF
stringToBool = (str) -> 
  if not str?
    return null
  else if str.match(/^(true|1|yes)$/i) != null
    return true
  else if str.match(/^(false|0|no)$/i) != null
    return false
  else
    return null

# interpret strings that correspond to integers between 0 and 13
interpret_alphabetic_number = (str) ->
  switch str
    when "zero", "no", "none" then 0
    when "one", "a", "an" then 1
    when "two", "a couple of", "couple", "a pair of" then 2
    when "three", "a few", "few", "some" then 3
    when "four" then 4
    when "five", "several" then 5 # "a handful"
    when "six" then 6
    when "seven" then 7
    when "eight" then 8
    when "nine" then 9
    when "ten" then 10
    when "eleven" then 11
    when "twelve", "dozen", "a dozen" then 12
    when "thirteen", "baker's dozen", "a baker's dozen" then 13


# list of alternatives of names of numbers, to be used in regex's below
alphabetic_number_alternatives = """
zero|no|none|one|a|an|two|three|four|five|several|
six|seven|eight|nine|ten|eleven|twelve|thirteen|some"""


# convert a string to a nonnegative integer
fuzzy_string_to_nonnegative_int = (str) -> 
  if str.trim().search(/[0-9]+/i) != -1 # contains numerals
    return parseInt(str, 10)
  else if str.search(/[a-z ]+/i) != -1 # contains letters
    return interpret_alphabetic_number str.trim()
  else
    return NaN


# escape characters for regex
regexEscape = (str) ->
  return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')


module.exports = (robot) ->
  tokenBot = new TokenNetwork robot

  ###
    Environment variables
  ###

  # name of the bot 
  bot_name = process.env.HUBOT_ROCKETCHAT_BOTNAME or "token"
  bot_alias = process.env.HUBOT_ALIAS or "/"
  bot_user = robot.brain.usersForFuzzyName(bot_name)[0]
  if bot_user? 
    bot_id = bot_user.id
  else
    bot_id = ""

  # whether tokens can be given or received. defaults to true
  if process.env.TOKENS_CAN_BE_TRANSFERRED?
    tokens_can_be_given_or_revoked = stringToBool(
      process.env.TOKENS_CAN_BE_TRANSFERRED)
  else
    tokens_can_be_given_or_revoked = true

  # whether people can give tokens to themself. defaults to false.
  if process.env.TOKEN_ALLOW_SELF?
    allow_self = stringToBool(process.env.TOKEN_ALLOW_SELF)
  else
    allow_self = true # TODO: change this default to false

  # default length for the leaderboard showing the people with the most tokens
  leaderboard_length = 10

  # # Reset everyone's wallet to the allowance environment variable
  reset_wallets = ->
    tokenBot.reset_everyones_wallet()
    msg = "@all: I just reset everyone's wallet to #{TOKEN_ALLOWANCE} tokens."
        # msg = "@all I just reset everyone's wallet to #{TOKEN_ALLOWANCE}" +
        #   " tokens. Make sure to thank #{TOKEN_ALLOWANCE} people for " +
        #   "giving useful feedback on their business ideas before these " +
        #   "tokens disappear next week!"
    robot.messageRoom ROOM_ANNOUNCE_ALLOWANCE, msg
    robot.messageRoom "general", (msg + " :)")

  timezone = process.env.TIMEZONE or "Africa/Accra"
  # "59 59 23 * * 0"
  frequency = process.env.ALLOWANCE_FREQUENCY or "0,20,40 * * * * *"
  job = new CronJob frequency, reset_wallets, null, true, timezone
  job.start
  #job2 = new CronJob frequency, robot.messageRoom("general", "test"), null, true, timezone

 
  give_regex_string = "give|send"
  give_regex = new RegExp("\\b(" + give_regex_string + ")\\b", "i")
  number_regex_string = "[0-9]+" + "|" + alphabetic_number_alternatives
  give_regex_string = "" +
    "\\b(" + give_regex_string +   # give or send (first capturing group)
    ")\\b" +  
    "(?:\\s+" +                    # number of tokens is optional (second capturing group)
    "\\b(" + number_regex_string + "|all" + ")\\b" + 
    ")?" +
    "(?:\\s+tokens{0,1})?" +       # token or tokens (optional)
    "(?:\\s+\\b(?:to)\\b)?" +      # to (optional)
    "\\s+" +                       # at least 1 charachter of whitespace
    "@?([\\w.\\-]+)" +             # user name or name (to be matched in a fuzzy way below) -- third capture group
    "\\s*$"                        # 0 or more whitespace
  give_revoke_regex = new RegExp(give_regex_string, "i")

  # respond to give or revoke commands
  robot.respond give_revoke_regex, (res) ->  # `res` is an instance of Response. 
    sender = res.message.user
    sender_name = "@" + res.message.user.name
    sender_id = res.message.user.id
    tokenBot.initialize_user_if_unrecognized sender_id

    # is the message a DM to the bot?
    # a message is a direct message if the message's room contains the
    # sender_id (because the room ID is a concatenation of the IDs of the
    # sender and recipients)
    is_direct_message = (res.message.room.indexOf(sender_id) > -1)

    # check whether the transferring tokens is frozen; 
    # if so, send a message and return
    if not tokens_can_be_given_or_revoked
      res.send "Sorry #{sender_name}, tokens can no longer be given nor revoked."
      robot.logger.info ("User {id: #{sender_id}, name: #{sender_name}} tried" + 
                          " to give a token but tokens cannot be given now.")
      return
    
    # figure out who the recipient is 
    recipient_name_raw = res.match[3] # third capture group in give_revoke_regex
    recipients = robot.brain.usersForFuzzyName(recipient_name_raw.trim()) 
    
    # check whether we identified just one person with that user name
    # if not, send a failure message and return
    if recipients.length != 1
      fail_message = ("Sorry #{sender_name}, I didn't understand that person " +
                      "( `#{recipient_name_raw}` ) to whom you're trying to give a token." +
                      "\n\nMake sure that you enter the person's user name correctly, " +
                      "either with or without a preceding @ symbol, such as `/give @user_name`. " +
                      "Also, if you did enter that person's user name correctly, " +
                      "I won't be able to give them a token from you until that " +
                      "person has sent at least one message in any channel.")
      res.send fail_message
      return

    # Now we know who the recipient is
    recipient = recipients[0]
    recipient_name = "@" + recipient.name
    recipient_id = recipient.id

    # Check whether the sender is trying to give a token to himself/herself and
    # allow_self is false. If so, return a random message saying that you can't
    # give a token to yourself.
    if not allow_self and res.message.user.id == recipient_id
      res.send res.random tokenBot.selfDeniedResponses(sender_name)
      log_message = ("User {id: #{sender_id}, name: #{sender_name}} tried to" +
                     " give himself/herself a token")
      robot.logger.info log_message
      return

    # figure out how many tokens they want to give
    # if the user doesn't provide a number, then assume that the number is 1
    num_tokens_to_transfer = switch
      when not res.match[2]? or res.match[2] == "" then 1
      when res.match[2] == "all" then tokenBot.token_wallet[sender_id]
      else fuzzy_string_to_nonnegative_int res.match[2]

    if num_tokens_to_transfer? and not isNaN num_tokens_to_transfer
      log_message = "{action: give, "
      log_message += "sender: {id: #{sender_id}, name: #{sender_name}}, "
      log_message += "recipient: {id: #{recipient_id}, name: #{recipient_name}}, "
      log_message += "is_direct_message: #{is_direct_message}, "
      log_message += "numtokens: #{num_tokens_to_transfer}}"
      robot.logger.info log_message
      message = tokenBot.give_token sender_id, recipient_id, num_tokens_to_transfer
      res.send message

      # if the command was given in a direct message to the bot, 
      # then send a direct message to the recipient to notify them
      # res.send "recipient: {id: #{recipient_id}, name: #{recipient_name}}"
      # res.send "res.envelope = #{Util.inspect res.envelope}"
      # res.send "res.envelope.user.name = #{res.envelope.user.name}"

      # msg.envelope.user.id = recipient_id
      # msg.sendDirect "test"

      # This isn't working yet ...
      # if false #is_direct_message
      #   direct_message = ("Psst. This action was done privately. " + message)
      #   #res.send "Attempting to send the following DM: #{direct_message}"
      #   #res.send "recipient_id = #{recipient_id}"
      #   #res.send "recipient_name = #{recipient_name}"
      #   #res.send "robot.adapter.chatdriver.getDirectMessageRoomId(recipient_name) = #{Util.inspect robot.adapter.chatdriver.getDirectMessageRoomId(recipient_name)}"
      #   #robot.logger.info "robot.adapter.chatdriver.getDirectMessageRoomId(recipient_id).room = #{robot.adapter.chatdriver.getDirectMessageRoomId(recipient).room}"
      #   #robot.adapter.chatdriver.sendMessageByRoomId direct_message, robot.adapter.chatdriver.getDirectMessageRoomId(recipient_name).room
        
      #   # room for the direct message
      #   # TODO: Need to find out how to get the user ID of the bot
      #   robot.logger.info "bot_id = #{bot_id}"
      #   direct_msg_room_id = robot.chatdriver.getDirectMessageRoomId recipient_name
      #   #room_id = [recipient_id, bot_id].sort().join('')
      #   robot.logger.info direct_message
      #   robot.logger.info ("room_id of the DM: " + direct_msg_room_id)
      #   robot.sendDirectToUsername recipient_name, message
    else
      fail_message = ("I didn't understand how many tokens you want to give." +
                      " If you don't provide a number, I assume you want to " +
                      " give one token. I also understand numbers like 1, 2," +
                      " 3 and some alphabetic numbers like one, two, three.")
      res.send fail_message
    return

  ###
    Status and leaderboard commands 
  ###

  # respond to "status (of) @user"
  robot.respond ///            
                status        # "status"
                (?:\s+of)?    # "of" is optional
                \s+           # whitespace
                @?([\w.\-]+)  # user name or name (to be matched in a fuzzy way below). 
                              # \w matches any word character (alphanumeric and underscore).
                \s*$          # 0 or more whitespace
                ///i, (res) ->

    name_raw = res.match[1]
    # the second capture group is the user name:
    users = robot.brain.usersForFuzzyName(name_raw.trim())

    if users.length == 1
      user = users[0]
      # whether the person writing the command is the one we're getting the status of
      self_bool = (user['id'] == res.message.user.id)
      tokenBot.initialize_user_if_unrecognized user['id']
      res.send tokenBot.status user['id'], self_bool # TODO: change res.send to res.sendPrivate
    else
      res.send "Sorry, I couldn't understand the name you provided ( `#{name_raw}` )." # TODO: change res.send to res.sendPrivate

  # Listen for the command `status` without any user name provided.
  # This sends the message returned by `tokenBot.status` on the input `res.message.user.name`.
  robot.respond ///
                \s*
                status
                \s*
                $///i, (res) ->
    tokenBot.initialize_user_if_unrecognized res.message.user.id
    res.send tokenBot.status res.message.user.id, true
    # TODO: change res.sendPrivate to res.sendPrivate

  # show leaderboard, show leader board
  robot.respond /\s*(?:show )?\s*leaders? ?board\s*/i, (res) ->
    res.send tokenBot.leaderboard leaderboard_length # TODO: change res.send to res.sendPrivate

  # who has the most tokens? 
  robot.respond /\s*who \b(has|holds)\b the most tokens\??\s*/i, (res) ->
    res.send tokenBot.leaderboard leaderboard_length # TODO: change res.send to res.sendPrivate

  # show top n list
  show_top_n_regex_string = "" +
    "(?:show)?" +         # "show" is optional
    "\\s+" +              # whitespace
    "(?:the\s+)?" +       # "the" is optional
    "top" +               # "top" is required
    "\\s+" +              # whitespace
    "(" + number_regex_string + ")" +     # length of leaderboard, such as "5" or "five"
    "(?:\\s+\\b(list|users|people)?\\b)?" # "list" or "users" or "people" is optional
  
  show_top_n_regex = new RegExp(show_top_n_regex_string, "i")

  robot.respond show_top_n_regex, (res) -> 
    # grab the length of the leaderboard (the first capturing group)
    number_input = res.match[1]

    number_parseInt = switch
      when number_input == "" or not number_input? then leaderboard_length # default value
      when number_input == "all" then robot.brain.data.users.length
      else fuzzy_string_to_nonnegative_int number_input

    # if we can successfully parse number_input as a base-10 integer, 
    # then send the result of tokenBot.leaderboard
    if not isNaN number_parseInt
      if number_parseInt > 0
        res.send tokenBot.leaderboard number_parseInt # TODO: change res.send to res.sendPrivate
      else
        msg = "Please provide a positive integer; for example, use the "
        msg += "command `#{bot_name} show top 5 list`."
        res.send msg
    else
      # it's not an integer, so try to interpret an English word for a number
      number_interpreted = interpret_alphabetic_number number_input
      if isNaN number_interpreted
        fail_message = ("Sorry, I didn't understand the number you provided " + 
                      "(` #{number_input} `). Use the command `#{bot_name} " + 
                      "show leaderboard` to show the top " + 
                      "#{leaderboard_length} list, or use `#{bot_name} show" +
                      " top n list` (where `n` is an integer) to show the `n`" +
                      " people who have received the most tokens.")
        res.send fail_message # TODO: change res.send to res.sendPrivate
      else
        res.send tokenBot.leaderboard number_interpreted # TODO: change res.send to res.sendPrivate

  ###
    Miscellaneous commands
  ###

  #log all errors 
  robot.error (err, res) ->
    robot.logger.error "#{err}\n#{err.stack}"
    if res?
       res.reply "#{err}\n#{err.stack}"

  # show user with tokens still to give out to others
  robot.respond ///
                \s*
                \b(show)?\s*
                \b(the)?\s*
                \b(people|everyone|users)?\s*
                \b(who|with)\s*
                \b(still)?\s*
                \b(has|have)\s*
                \b(tokens)
                \b(to give\b(out)?)?
                \s*\??
                \s*
                ///i, (res) ->
    sender_id = res.message.user.id
    tokenBot.initialize_user_if_unrecognized sender_id
    # check whether tokenBot.tokens_given is empty
    if Object.keys(tokenBot.tokens_given).length == 0
      msg = "No one has said anything yet, so I don't know of the existence of anyone yet!"
      # TODO: change res.send to res.sendPrivate
      res.send msg
    else
      response = ""
      for own id, tokens_remaining of tokenBot.token_wallet
        if tokens_remaining > 0
          username = "@" + robot.brain.userForId(id).name
          token_or_tokens = if tokens_remaining != 1 then "tokens" else "token"
          if response != ""
            resposne += ", "
          response += "#{username} (#{tokens_remaining} #{token_or_tokens})"
      if response == ""
        # TODO: change res.send to res.sendPrivate
        res.send "Everyone has given out all their tokens."
      else
        # TODO: change res.send to res.sendPrivate
        preamble = "The following users still have tokens to give. Try to help"
        preamble += " these users so that they thank you with a token!\n"
        res.send (preamble + response)

  # if this is the first time that this user has said something, then
  # initialize this user in the dictionaries of tokens sent, tokens received,
  # and tokens available to give
  robot.hear /.*/i, (res) ->
    sender_id = res.message.user.id
    tokenBot.initialize_user_if_unrecognized sender_id

  # # when a user enters the room, initialize them in the tokenBot's dictionaries
  # # if this user's ID is not already a key in those dictionaries
  robot.enter (res) -> 
    sender_id = res.message.user.id
    tokenBot.initialize_user_if_unrecognized sender_id

  robot.respond /hi|hello|hey/i, (res) ->
    sender = res.message.user
    sender_name = "@" + res.message.user.name
    res.send "Hi #{sender_name}!"

  robot.respond /(what is|what's) your name\??/i, (res) -> 
    res.send "My name is #{bot_name}. You can give commands in the form `#{bot_name} <command>`."
    #res.send "My ID is #{Util.inspect robot.brain.usersForFuzzyName(bot_name.trim())}"

  robot.hear /how do I \b(?:give|send)\b(?:\s+a)? tokens?\??/i, (res) -> 
    res.send "Use the command `/give @user_name`."

  ###
    DEBUGGING
  ###
  # inspect a user's user name
  robot.respond /inspect me/i, (res) ->
    user = robot.brain.userForId(res.message.user.id)
    res.send "#{Util.inspect(user)}"

  # show users, show all users -- show all users and their user names
  robot.respond /show (?:all )?users$/i, (res) ->
    msg = "Here are all the users I know about: "
    msg += ("@#{user.name}" for own key, user of robot.brain.data.users).join ", "
    res.send msg

  robot.respond /show your brain/i, (res) -> 
    res.send "#{Util.inspect(robot.brain.data.users)}"
    res.send "tokenBot.tokens_given = #{Util.inspect(tokenBot.tokens_given)}"
    res.send "tokenBot.tokens_received = #{Util.inspect(tokenBot.tokens_received)}"
    res.send "tokenBot.token_wallet = #{Util.inspect(tokenBot.token_wallet)}"
    res.send "Util.inspect robot.brain = #{ Util.inspect robot.brain }"

  # TODO remove this command before putting this into production.
  robot.respond /reset wallets/i, (res) ->
    reset_wallets()
    res.send "Just reset wallets"

